#include <iostream>
#include <vector>
#include <assert.h>
#include "matrix.h"
#include "grid.h"

#define harmonic_average(a,b)   (2.0*(a)*(b)/((a)+(b)))

using namespace std;

const double xmin = 0.0;
const double xmax = 1.0;
const double ymin = 0.0;
const double ymax = 1.0;
const double inlet_length = 0.1;
const double outlet_length= 0.1;
const double viscosity_oil = 10.0;

// viscosity of water as function of polymer concentration
double viscosity_water (const double concentration)
{
   return 1.0;
}

// mobility of water
double mobility_water (const double saturation, const double concentration)
{
   return saturation * saturation / viscosity_water (concentration);
}

// mobility of oil
double mobility_oil (const double saturation, const double concentration)
{
   return (1.0 - saturation) * (1.0 - saturation) / viscosity_oil;
}

// total mobility
double mobility_total (const double saturation, const double concentration)
{
   return mobility_water (saturation, concentration) +
          mobility_oil   (saturation, concentration);
}

// permeability of rock
double permeability (const double x, const double y)
{
   return 1.0;
}

class Point
{
   public:
      Point () {};
      ~Point () {};
      double operator() (const unsigned int index) const;

   private:
      double coord[2];
};

inline
double Point::operator() (const unsigned int index) const
{
   return coord[index];
}


class PressureProblem
{
   public:
      PressureProblem () {};
      ~PressureProblem () {};
      void copy_grid (const Grid&);
      void run (const vector<double>& Saturation, 
                const vector<double>& Concentration,
                      vector<double>& Pressure);

   private:
      Grid           grid;

      void compute_rhs ();
      void A_times_pressure (const vector<double>&,
                             const vector<double>&,
                             const vector<double>&);
};


// Copy gridin into local copy
void PressureProblem::copy_grid (const Grid& gridin)
{
   grid = gridin;
}

// compute rhs (b) of pressure equation A*p=b
void PressureProblem::compute_rhs ()
{
}

// compute matrix vector product A*b in pressure equation A*p = b
void PressureProblem::A_times_pressure (const vector<double>& Saturation,
                                        const vector<double>& Concentration,
                                        const vector<double>& Pressure)
{
   unsigned int i, j, n;
   unsigned int left, right, bottom, top;
   double mobility_center, mobility_left, mobility_right, 
          mobility_bottom, mobility_top;
   double w_left, w_right, w_bottom, w_top;
   vector<double> result(grid.ncells);

   // interior cells
   for(i=1; i<grid.nx-1; ++i)
      for(j=1; j<grid.ny-1; ++j)
      {
         n      = grid.cell_num(i,  j  );
         left   = grid.cell_num(i-1,j  );
         right  = grid.cell_num(i+1,j  );
         bottom = grid.cell_num(i,  j-1);
         top    = grid.cell_num(i,  j+1);

         mobility_center = mobility_total (Saturation[n],      Concentration[n]);
         mobility_left   = mobility_total (Saturation[left],   Concentration[left]);
         mobility_right  = mobility_total (Saturation[right],  Concentration[right]);
         mobility_bottom = mobility_total (Saturation[bottom], Concentration[bottom]);
         mobility_top    = mobility_total (Saturation[top],    Concentration[top]);

         w_left   = harmonic_average( mobility_center, mobility_left );
         w_right  = harmonic_average( mobility_center, mobility_right );
         w_bottom = harmonic_average( mobility_center, mobility_bottom );
         w_top    = harmonic_average( mobility_center, mobility_top );

         result[n] =   w_right  * (Pressure[right] - Pressure[n])
                     - w_left   * (Pressure[n]     - Pressure[left])
                     + w_top    * (Pressure[top]   - Pressure[n])
                     - w_bottom * (Pressure[n]     - Pressure[bottom]);
      }

   // bottom row cells other than inlet/bottom-right-corner
   j = 0;
   for(i=grid.ni; i<grid.nx-1; ++i)
   {
      n      = grid.cell_num(i,  j  );
      left   = grid.cell_num(i-1,j  );
      right  = grid.cell_num(i+1,j  );
      top    = grid.cell_num(i,  j+1);

      mobility_center = mobility_total (Saturation[n],      Concentration[n]);
      mobility_left   = mobility_total (Saturation[left],   Concentration[left]);
      mobility_right  = mobility_total (Saturation[right],  Concentration[right]);
      mobility_top    = mobility_total (Saturation[top],    Concentration[top]);

      w_left   = harmonic_average( mobility_center, mobility_left );
      w_right  = harmonic_average( mobility_center, mobility_right );
      w_top    = harmonic_average( mobility_center, mobility_top );

      result[n] =   w_right  * (Pressure[right] - Pressure[n])
                  - w_left   * (Pressure[n]     - Pressure[left])
                  + w_top    * (Pressure[top]   - Pressure[n]);
   }

   // bottom, right corner cell
   i = grid.nx - 1;
   j = 0;
   n      = grid.cell_num(i,  j  );
   left   = grid.cell_num(i-1,j  );
   top    = grid.cell_num(i,  j+1);

   mobility_center = mobility_total (Saturation[n],      Concentration[n]);
   mobility_left   = mobility_total (Saturation[left],   Concentration[left]);
   mobility_top    = mobility_total (Saturation[top],    Concentration[top]);

   w_left   = harmonic_average( mobility_center, mobility_left );
   w_top    = harmonic_average( mobility_center, mobility_top );

   result[n] = - w_left * (Pressure[n]     - Pressure[left])
               + w_top  * (Pressure[top]   - Pressure[n]);

   // right-most cells other than outlet/bottom-right-corner
   i = grid.nx - 1;
   for(j=1; j<grid.ny-grid.no; ++j)
   {
      n      = grid.cell_num(i,  j  );
      left   = grid.cell_num(i-1,j  );
      bottom = grid.cell_num(i,  j-1);
      top    = grid.cell_num(i,  j+1);

      mobility_center = mobility_total (Saturation[n],      Concentration[n]);
      mobility_left   = mobility_total (Saturation[left],   Concentration[left]);
      mobility_bottom = mobility_total (Saturation[bottom], Concentration[bottom]);
      mobility_top    = mobility_total (Saturation[top],    Concentration[top]);

      w_left   = harmonic_average( mobility_center, mobility_left );
      w_right  = harmonic_average( mobility_center, mobility_right );
      w_bottom = harmonic_average( mobility_center, mobility_bottom );

      result[n] = - w_left   * (Pressure[n]     - Pressure[left])
                  + w_top    * (Pressure[top]   - Pressure[n])
                  - w_bottom * (Pressure[n]     - Pressure[bottom]);
   }

   // left-most cells other than inlet/top-left-corner
   i = 0;
   for(j=grid.ni; j<grid.ny-1; ++j)
   {
         n      = grid.cell_num(i,  j  );
         //left   = grid.cell_num(i-1,j  );
         right  = grid.cell_num(i+1,j  );
         bottom = grid.cell_num(i,  j-1);
         top    = grid.cell_num(i,  j+1);

         mobility_center = mobility_total (Saturation[n],      Concentration[n]);
         //mobility_left   = mobility_total (Saturation[left],   Concentration[left]);
         mobility_right  = mobility_total (Saturation[right],  Concentration[right]);
         mobility_bottom = mobility_total (Saturation[bottom], Concentration[bottom]);
         mobility_top    = mobility_total (Saturation[top],    Concentration[top]);

         //w_left   = harmonic_average( mobility_center, mobility_left );
         w_right  = harmonic_average( mobility_center, mobility_right );
         w_bottom = harmonic_average( mobility_center, mobility_bottom );
         w_top    = harmonic_average( mobility_center, mobility_top );

         result[n] =   w_right  * (Pressure[right] - Pressure[n])    
                   //- w_left   * (Pressure[n]     - Pressure[left])
                     + w_top    * (Pressure[top]   - Pressure[n])
                     - w_bottom * (Pressure[n]     - Pressure[bottom]);
   }

   // top-most cells other than outlet/top-left-corner
   j = grid.ny - 1;
   for(i=1; i<grid.nx-grid.no; ++i)
   {
         n      = grid.cell_num(i,  j  );
         left   = grid.cell_num(i-1,j  );
         right  = grid.cell_num(i+1,j  );
         bottom = grid.cell_num(i,  j-1);
         //top    = grid.cell_num(i,  j+1);

         mobility_center = mobility_total (Saturation[n],      Concentration[n]);
         mobility_left   = mobility_total (Saturation[left],   Concentration[left]);
         mobility_right  = mobility_total (Saturation[right],  Concentration[right]);
         mobility_bottom = mobility_total (Saturation[bottom], Concentration[bottom]);
         //mobility_top    = mobility_total (Saturation[top],    Concentration[top]);

         w_left   = harmonic_average( mobility_center, mobility_left );
         w_right  = harmonic_average( mobility_center, mobility_right );
         w_bottom = harmonic_average( mobility_center, mobility_bottom );
         //w_top    = harmonic_average( mobility_center, mobility_top );

         result[n] =   w_right  * (Pressure[right] - Pressure[n])
                     - w_left   * (Pressure[n]     - Pressure[left])
                   //+ w_top    * (Pressure[top]   - Pressure[n])
                     - w_bottom * (Pressure[n]     - Pressure[bottom]);
   }

   // top-left-corner cell
   i = 0;
   j = grid.ny - 1;
   n      = grid.cell_num(i,  j  );
   //left   = grid.cell_num(i-1,j  );
   right  = grid.cell_num(i+1,j  );
   bottom = grid.cell_num(i,  j-1);
   //top    = grid.cell_num(i,  j+1);

   mobility_center = mobility_total (Saturation[n],      Concentration[n]);
   //mobility_left   = mobility_total (Saturation[left],   Concentration[left]);
   mobility_right  = mobility_total (Saturation[right],  Concentration[right]);
   mobility_bottom = mobility_total (Saturation[bottom], Concentration[bottom]);
   //mobility_top    = mobility_total (Saturation[top],    Concentration[top]);

   //w_left   = harmonic_average( mobility_center, mobility_left );
   w_right  = harmonic_average( mobility_center, mobility_right );
   w_bottom = harmonic_average( mobility_center, mobility_bottom );
   //w_top    = harmonic_average( mobility_center, mobility_top );

   result[n] =   w_right  * (Pressure[right] - Pressure[n])
             //- w_left   * (Pressure[n]     - Pressure[left])
             //+ w_top    * (Pressure[top]   - Pressure[n])
               - w_bottom * (Pressure[n]     - Pressure[bottom]);

}

// Solve pressure equation by CG method
void PressureProblem::run (const vector<double>& Saturation, 
                           const vector<double>& Concentration,
                                 vector<double>& Pressure)
{
   const unsigned int max_iter = 1000;
   const double tolerance = 1.0e-6;
   unsigned int iter = 0;
   double residue = 1.0;
   vector<double> direction(grid.ncells);

   compute_rhs ();

   while ( residue > tolerance && iter < max_iter )
   {
      A_times_pressure (Saturation, Concentration, Pressure);
      ++iter;
   }
}

// Class for reservoir problem
class ReservoirProblem
{
   public:
      ReservoirProblem () {};
      ReservoirProblem (const Grid& grid);
      ~ReservoirProblem () {};
      void run ();

   private:
      double         final_time, dt;
      Grid           grid;
      vector<double> Saturation;
      vector<double> Concentration;
      vector<double> Pressure;
      vector<double> Residual;
      PressureProblem pressure_problem;

      double saturation (unsigned int i, unsigned int j);
      double concentration (unsigned int i, unsigned int j);
      double pressure (unsigned int i, unsigned int j);
      void initialize ();
      void time_step ();
      void output ();
};

// constructor
ReservoirProblem::ReservoirProblem (const Grid& gridin)
{
   grid = gridin;

   unsigned int ncells = grid.nx * grid.ny;

   Saturation.resize (ncells);
   Concentration.resize (ncells);
   Pressure.resize (ncells);

   pressure_problem.copy_grid (gridin);

   dt = 0.1;
   final_time = 0.1;
}

double ReservoirProblem::saturation (unsigned int i, unsigned int j)
{
   unsigned int n = grid.cell_num (i,j);
   return Saturation[n];
}

double ReservoirProblem::concentration (unsigned int i, unsigned int j)
{
   unsigned int n = grid.cell_num (i,j);
   return Concentration[n];
}

double ReservoirProblem::pressure (unsigned int i, unsigned int j)
{
   unsigned int n = grid.cell_num (i,j);
   return Pressure[n];
}

// Set initial condition for saturation and concentration
void ReservoirProblem::initialize ()
{
   unsigned int n = 0;

   cout << "Setting initial conditions ... ";

   for(unsigned int i=0; i<grid.nx; ++i)
      for(unsigned int j=0; j<grid.ny; ++j){
         double x = i*grid.dx;
         double y = j*grid.dy;
         Saturation[n] = 1.0;
         Concentration[n] = 0.0;
         Pressure[n] = 0.0;
         ++n;
      }

   cout << "Done" << endl;
}

// update saturation and concentration
void ReservoirProblem::time_step ()
{
}

// save solution to file
void ReservoirProblem::output ()
{
}

// Solve the reservoir problem
void ReservoirProblem::run ()
{
   initialize ();
   for(double time=0; time < final_time; time+=dt){
      pressure_problem.run (Saturation, Concentration, Pressure);
      time_step ();
   }

   output ();
}

// Execution starts here
int main ()
{
   Grid              grid (100, 100);
   ReservoirProblem  reservoir_problem(grid);

   reservoir_problem.run ();

   return 0;
}
